	// template<class T>
	// class iterator : public std::iterator<std::random_access_iterator_tag, T>
	// {
	// 	private:
	// 		T* z;
	// 	public:
	// 	typedef ptrdiff_t difference_type;
	// 	typedef T value_type;
	// 	typedef T& reference;
	// 	typedef const T& const_refernce;
	// 	typedef T* pointer;
	// 	iterator(T* init){z = init;};
	// 	iterator(){z = NULL;}
	// 	iterator base(void) { iterator tmp = z;return --tmp; }
	// 	bool 			operator != (const iterator &v){return this->z != v.z;}
	// 	bool 			operator== (const iterator &v){return this->z == v.z;}
	// 	bool 			operator>(const iterator &v){return this->z > v.z;}
	// 	bool 			operator>=(const iterator &v){return this->z >= v.z;}
	// 	bool 			operator<(const iterator &v){return this->z < v.z;}
	// 	bool 			operator<=(const iterator &v){return this->z <= v.z;}
	// 	size_t 		operator-(const iterator &v){iterator tmp(*this);size_t t = (size_t)(tmp.z - v.z); return t;}
	// 	iterator 		operator-(size_t v)const {iterator tmp(*this); tmp.z -= v; return tmp;}
	// 	iterator 		operator+(size_t v) const {iterator tmp(*this); tmp.z += v; return tmp;}
	// 	iterator 		&operator++(){this->z++;return *this;}
	// 	iterator 		&operator--(){(this->z)--;return *this;}
	// 	iterator 		&operator--(int){iterator tmp = *this;(this->z)--;return *this;}
	// 	iterator		operator++(int) {iterator copy = *this;this->z++;return copy;}
	// 	iterator& operator+=(const int& rhs){
	// 		this->z += rhs;
	// 		return *this;}
	// 	iterator& operator-=(const int& rhs){
	// 		this->z -= rhs;
	// 		return *this;}
	// 	reference	operator*(){return *z;};
	// 	pointer			operator->(){return z;}
	// 	reference operator[] (size_type n){return z[n];}
	// 	friend iterator operator + (size_t l,const iterator& r)
	// 	{
  	// 		return r + l;   
	// 	}
	// iterator& operator =(const iterator& a)
    //     {
    //         this->z = a.z;
    //         return *this;
    //     }
	// 	// operator const_iterator () {return z;}
	// operator const_iterator() const{ return z;}


	// };
	// 	class const_iterator : public std::iterator<std::random_access_iterator_tag, const T>
	// {
	// 	private:
	// 		T* z;
	// 	public:
	// 	typedef ptrdiff_t difference_type;
	// 	typedef T value_type;
	// 	typedef T& reference;
	// 	typedef const T& const_refernce;
	// 	typedef T* pointer;
	// 	const_iterator(T* init){z = init;};
	// 	const_iterator(){z = NULL;}
	// 	const_iterator(iterator&t){z = t;}
	// 	const_iterator base(void) { const_iterator tmp = z;return --tmp; }
	// 	bool 			operator != (const const_iterator &v){return this->z != v.z;}
	// 	bool 			operator== (const const_iterator &v){return this->z == v.z;}
	// 	bool 			operator>(const const_iterator &v){return this->z > v.z;}
	// 	bool 			operator>=(const const_iterator &v){return this->z >= v.z;}
	// 	bool 			operator<(const const_iterator &v){return this->z < v.z;}
	// 	bool 			operator<=(const const_iterator &v){return this->z <= v.z;}
	// 	size_t 		operator-(const const_iterator &v){const_iterator tmp(*this);size_t t = (size_t)(tmp.z - v.z); return t;}
	// 	const_iterator 		operator-(size_t v)const {const_iterator tmp(*this); tmp.z -= v; return tmp;}
	// 	const_iterator 		operator+(size_t v) const {const_iterator tmp(*this); tmp.z += v; return tmp;}
	// 	const_iterator 		&operator++(){this->z++;return *this;}
	// 	const_iterator 		&operator--(){(this->z)--;return *this;}
	// 	const_iterator 		&operator--(int){const_iterator tmp = *this;(this->z)--;return *this;}
	// 	const_iterator		operator++(int) {const_iterator copy = *this;this->z++;return copy;}
	// 	const_iterator& operator+=(const int& rhs){
	// 		this->z += rhs;
	// 		return *this;}
	// 	const_iterator& operator-=(const int& rhs){
	// 		this->z -= rhs;
	// 		return *this;}
	// 	reference	operator*(){return *z;};
	// 	pointer			operator->(){return z;}
	// 	reference operator[] (size_type n){return z[n];}
	// 	friend const_iterator operator + (size_t l,const const_iterator& r)
	// 	{
  	// 		return r + l;   
	// 	}
	// const_iterator& operator =(const const_iterator& a)
    //     {
    //         this->z = a.z;
    //         return *this;
    //     }
	// 	// operator const_iterator () {return z;}
	// // operator iterator<const iterator>() const{ return iterator<const T>(z);}


	// };
	
	// typedef iterator<const T> const_iterator;

	// // iterator 		operator+(int v,iterator& f){f+=v; return f;}
	// class const_iterator : public std::iterator<std::random_access_iterator_tag, T>
	// {
	// 	private:
	// 		T* z;
	// 	public:
	// 	typedef ptrdiff_t difference_type;
	// 	typedef T value_type;
	// 	typedef T& reference;
	// 	typedef const T& const_refernce;
	// 	typedef T* pointer;
	// 	const_iterator(T* init){z = init;};
	// 	const_iterator(){z = NULL;} 
	// 	const_iterator(iterator&t){z = t.base();}
	// 	const_iterator base(void) { const_iterator tmp = z;return --tmp; }
	// 	bool 			operator != (const const_iterator &v){return this->z != v.z;}
	// 	bool 			operator== (const const_iterator &v){return this->z == v.z;}
	// 	bool 			operator>(const const_iterator &v){return this->z > v.z;}
	// 	bool 			operator>=(const const_iterator &v){return this->z >= v.z;}
	// 	bool 			operator<(const const_iterator &v){return this->z < v.z;}
	// 	bool 			operator<=(const const_iterator &v){return this->z <= v.z;}
	// 	size_t 		operator-(const const_iterator &v){const_iterator tmp(*this);size_t t = (size_t)(tmp.z - v.z); return t;}
	// 	const_iterator 		operator-(size_t v)const {const_iterator tmp(*this); tmp.z -= v; return tmp;}
	// 	const_iterator 		operator+(size_t v) const {const_iterator tmp(*this); tmp.z += v; return tmp;}
	// 	const_iterator 		&operator++(){this->z++;return *this;}
	// 	const_iterator 		&operator--(){(this->z)--;return *this;}
	// 	const_iterator 		&operator--(int){const_iterator tmp = *this;(this->z)--;return *this;}
	// 	const_iterator		operator++(int) {const_iterator copy = *this;this->z++;return copy;}
	// 	const_iterator& operator+=(const int& rhs){
	// 		this->z += rhs;
	// 		return *this;}
	// 	const_iterator& operator-=(const int& rhs){
	// 		this->z -= rhs;
	// 		return *this;}
	// 	reference	operator*(){return *z;};
	// 	pointer			operator->(){return z;}
	// 	reference operator[] (size_type n){return z[n];}
	// 	friend const_iterator operator + (size_t l,const const_iterator& r)
	// 	{
  	// 		return r + l;   
	// 	}
	// const_iterator& operator =(const const_iterator& a)
    //     {
    //         this->z = a.z;
    //         return *this;
    //     }

	// };
	// class const_iterator : public std::iterator<std::random_access_iterator_tag, T>
	// {
	// 	private:
	// 		T* z;
	// 	public:
	// 	typedef T value_type;
	// 	typedef T& reference;
	// 	typedef const T& const_refernce;
	// 	typedef T* pointer;
	// 	const_iterator(T* init){z = init;};
	// 	const_iterator(){z = NULL;}
	// 	const_iterator(iterator&f){z = f.z;}
	// 	bool 			operator != (const const_iterator &v){return this->z != v.z;}
	// 	bool 			operator== (const const_iterator &v){return this->z == v.z;}
	// 	bool 			operator>(const const_iterator &v){return this->z > v.z;}
	// 	bool 			operator>=(const const_iterator &v){return this->z >= v.z;}
	// 	bool 			operator<(const const_iterator &v){return this->z < v.z;}
	// 	bool 			operator<=(const const_iterator &v){return this->z <= v.z;}
	// 	// const_iterator 		operator+(const const_iterator &v){const_iterator tmp;tmp->z+v.z;return *this;}
	// 	const_iterator 		operator-(const const_iterator &v){const_iterator tmp;tmp->z-v.z;return *this;}
	// 	const_iterator 		operator-(int v){const_iterator tmp(*this);tmp.z -= v; return tmp;}
	// 	const_iterator 		operator+(int v){const_iterator tmp(*this);tmp.z += v; return tmp;}
	// 	const_iterator 		&operator++(){this->z++;return *this;}
	// 	const_iterator 		&operator--(){(this->z)--;return *this;}
	// 	const_iterator 		&operator--(int){const_iterator tmp = *this;(this->z)--;return *this;}
	// 	const_iterator		operator++(int) {const_iterator copy = *this;this->z++;return copy;}
	// 	reference	operator*(){return *z;};
	// 	pointer			operator->(){return z;}
	// 	reference operator[] (size_type n){return z[n];}
	// 	friend iterator operator + (size_t l,const iterator& r)
	// 	{
  	// 		return r + l;   
	// 	}
	// };

	// class reverse_iterator : public std::iterator<std::random_access_iterator_tag, T>
	// {
	// 	private:
	// 		T* z;
	// 	public:
	// 	typedef T value_type;
	// 	typedef T& reference;
	// 	typedef const T& const_refernce;
	// 	typedef T* pointer;
	// 	reverse_iterator(T* init){z = init;};
	// 	reverse_iterator(){z = NULL;}
	// 	bool 			operator != (const reverse_iterator &v){return this->z != v.z;}
	// 	bool 			operator== (const reverse_iterator &v){return this->z == v.z;}
	// 	bool 			operator>(const reverse_iterator &v){return this->z > v.z;}
	// 	bool 			operator>=(const reverse_iterator &v){return this->z >= v.z;}
	// 	bool 			operator<(const reverse_iterator &v){return this->z < v.z;}
	// 	bool 			operator<=(const reverse_iterator &v){return this->z <= v.z;}
	// 	reverse_iterator 		operator+(const reverse_iterator &v){reverse_iterator tmp;tmp->z-v.z;return *this;}
	// 	reverse_iterator 		operator-(const reverse_iterator &v){reverse_iterator tmp;tmp->z+v.z;return *this;}
	// 	reverse_iterator 		operator-(int v){reverse_iterator tmp(*this);tmp.z += v; return tmp;}
	// 	reverse_iterator 		operator+(int v){reverse_iterator tmp(*this);tmp.z -= v; return tmp;}
	// 	reverse_iterator 		&operator++(){this->z--;return *this;}
	// 	reverse_iterator 		&operator--(){(this->z)++;return *this;}
	// 	reverse_iterator 		&operator--(int){reverse_iterator tmp = *this;(this->z)++;return *this;}
	// 	reverse_iterator		operator++(int) {reverse_iterator copy = *this;this->z--;return copy;}
	// 	reference	operator*(){return *z;};
	// 	pointer			operator->(){return z;}
	// };

		// 	template<typename>    struct is_integral {static const bool value = false;};
	// 	template<>             struct is_integral<bool> {static const bool value = true;};
	// 	template<>             struct is_integral<char> {static const bool value = true;};
	// 	template<>             struct is_integral<signed char> {static const bool value = true;};
	// 	template<>             struct is_integral<short int> {static const bool value = true;};
	// 	template<>             struct is_integral<int> {static const bool value = true;};
	// 	template<>             struct is_integral<long int> {static const bool value = true;};
	// 	template<>             struct is_integral<long long int> {static const bool value = true;};
	// 	template<>             struct is_integral<unsigned char> {static const bool value = true;};
	// 	template<>             struct is_integral<unsigned short int> {static const bool value = true;};
	// 	template<>             struct is_integral<unsigned int> {static const bool value = true;};
	// 	template<>             struct is_integral<unsigned long int> {static const bool value = true;};
	// 	template<>             struct is_integral<unsigned long long int> {static const bool value = true;};

    // template<bool Condition, typename TC = void>
    // struct enable_if
    // {
    // };
    // template<typename TC>
    // struct enable_if<true, TC>
    // {
    //     typedef TC type;
    // };